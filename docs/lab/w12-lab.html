<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Jeremy Hemberger and Brian Aukema">
<meta name="dcterms.date" content="2025-07-25">

<title>Lab 11: Lattice data: Spatial linear models – Entomology 5126</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../media/web-favicon.png" rel="icon" type="image/png">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/quarto-contrib/fontawesome6-1.2.0/all.min.css" rel="stylesheet">
<link href="../site_libs/quarto-contrib/fontawesome6-1.2.0/latex-fontsize.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../media/5126-sticker.png" alt="" class="navbar-logo">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../syllabus.html"> 
<span class="menu-text">Syllabus</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../schedule.html"> 
<span class="menu-text">Schedule</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../content/index.qmd"> 
<span class="menu-text">Content</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../lab/index.html"> 
<span class="menu-text">Labs</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../resources.html"> 
<span class="menu-text">Resources</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../media/ent5126-syllabus_sp2026.pdf" target="_blank"> <i class="bi bi-file-pdf" role="img">
</i> 
<span class="menu-text">Course Syllabus</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/jhemberger/entomology-5126" target="_blank"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="mailto:jhemberg@umn.edu"> <i class="bi bi-envelope" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#spatial-linear-models" id="toc-spatial-linear-models" class="nav-link" data-scroll-target="#spatial-linear-models">Spatial Linear Models</a></li>
  <li><a href="#todays-assignment" id="toc-todays-assignment" class="nav-link" data-scroll-target="#todays-assignment">Today’s Assignment</a>
  <ul class="collapse">
  <li><a href="#r-packages-for-today" id="toc-r-packages-for-today" class="nav-link" data-scroll-target="#r-packages-for-today"><code>R</code> packages for today</a></li>
  <li><a href="#we-could-use-a-map" id="toc-we-could-use-a-map" class="nav-link" data-scroll-target="#we-could-use-a-map">We could use a map!</a></li>
  <li><a href="#producing-maps-in-r-courtesy-of-jake" id="toc-producing-maps-in-r-courtesy-of-jake" class="nav-link" data-scroll-target="#producing-maps-in-r-courtesy-of-jake">Producing maps in <code>R</code> (courtesy of Jake)</a></li>
  <li><a href="#assignment" id="toc-assignment" class="nav-link" data-scroll-target="#assignment">Assignment</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Lab 11: Lattice data: Spatial linear models</h1>
<p class="subtitle lead">Entomology 5126 - Spring 2026</p>
</div>



<div class="quarto-title-meta column-page-left">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Jeremy Hemberger and Brian Aukema </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">July 25, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<hr>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Today we will focus on spatial linear models, commonly used with <em>lattice</em> or <em>areal</em> data. The goals are similar to previous linear models: explain some response <span class="math inline">\(y\)</span> by some covariates or factors (the <span class="math inline">\(x\)</span>’s). With spatial data, however, the autocorrelation - especially among the errors - may present problems.</p>
</section>
<section id="spatial-linear-models" class="level1">
<h1>Spatial Linear Models</h1>
<p>There are four steps to fitting spatial linear models:</p>
<ol type="1">
<li><p>Choose and define a neighborhood structure for your data</p></li>
<li><p>Choose a weighting scheme, if any, for your neighborhood structure</p></li>
<li><p>Fit and select your model(s) of choice</p></li>
<li><p>Check the residuals for [normality and homoscedasticity and] spatial autocorrelation</p></li>
</ol>
<p>That’s all there is to it!<br>
In the notes I have provided some rudimentary information about a variety of spatial linear models such as SAR and CAR models. There are more, like MA and IAR and STCAR models, but we will not cover them.<br>
We’ll work with a SAR model today. The general form for a first-order SAR model:</p>
<p><span class="math display">\[\begin{aligned}
Y_i &amp;=&amp; b_0+b_1 x_i+e_i,\\
e_i &amp;=&amp; \rho \sum_{j=1}^n s_{ij} e_j + u_i,
\end{aligned}\]</span> where <span class="math inline">\(u_i\sim {\rm ind} N(0,\sigma^2 v_i)\)</span> and <span class="math display">\[\begin{aligned}
s_{ij} &amp;=&amp; \left\{\begin{array}{l@{\quad;\quad}l}
1 &amp; i\neq j,~{\rm and} ~i~{\rm and}~j~{\rm are~neighbors},\\
0 &amp; i=j,~{\rm or} ~i~{\rm and}~j~{\rm are~not~neighbors}.
\end{array}\right.
\end{aligned}\]</span></p>
<p>Recall that<br>
</p>
<ul>
<li><p>The weights <span class="math inline">\(s_{ij}\)</span> represents the dependence of <span class="math inline">\(i\)</span> on the neighbor <span class="math inline">\(j\)</span>.</p></li>
<li><p>Different neighborhood structures can be selected (beyond first-order), offering very different <span class="math inline">\(s_{ij}\)</span>’s.</p></li>
<li><p>Likewise, we can choose different weights if we’d like.</p></li>
</ul>
<p>endframe</p>
</section>
<section id="todays-assignment" class="level1">
<h1>Today’s Assignment</h1>
<p>The data set <code>Lab12.xls</code> contains the number of tornadoes recorded in select counties in Wisconsin from 1950 to 1984. The included counties focus on the East-Central area of the state. The general goal of this assignment is to determine whether there is a spatial pattern to the numbers of tornadoes.<br>
(As an aside, this is a real data set that originated in an advanced spatial statistics course at the University of Wisconsin-Madison. Actually, however, I never got around to doing the assignment when I took the course in 2005. I am glad that you behave better than I did. After all, you may be asked to teach this material someday!)<br>
</p>
<div class="center">
<p>Variable Description</p>
<hr>
<p>id Row identifier county County in the state of Wisconsin tornadoes Number of tornadoes spotted between 1950 and 1984 area Land area of county in square miles pop90 Population in 1990 Nlat Latitude Wlong Longitude UTMEast Easting coordinate (<span class="math inline">\(x\)</span> position) in km UTMNorth Northing coordingate (<span class="math inline">\(y\)</span> position) in km</p>
</div>
<section id="r-packages-for-today" class="level2">
<h2 class="anchored" data-anchor-id="r-packages-for-today"><code>R</code> packages for today</h2>
<p>The most powerful and flexible package for spatial linear models is the <code>spatialreg</code> package. There are others, especially useful for non-normally distributed responses. Load and use the <code>spatialreg</code> and <code>spdep</code> packages today. The <code>spdep</code> package is used to specify spatial neighborhooods and contains functions to test for spatial autocorrelation. Both packages are written and maintained by Roger Bivand, a true pioneer in the field of lattice data analysis. He is an economic geographer at the Norwegian School of Economics in Bergen, Norway.</p>
<p>If you would like to explore mapping as well (below, optional), load the <code>maps</code>, <code>maptools</code>, and <code>ggplot2</code> packages as well.</p>
</section>
<section id="we-could-use-a-map" class="level2">
<h2 class="anchored" data-anchor-id="we-could-use-a-map">We could use a map!</h2>
<p>On the course website, I’ve included a PDF of a map of the counties included in this analysis. The map is for reference only. The numbers on the bottom panel indicate the number of tornadoes. Alternatively, you can learn how to create a similar map in <code>R</code> below. Again, this is optional.</p>
</section>
<section id="producing-maps-in-r-courtesy-of-jake" class="level2">
<h2 class="anchored" data-anchor-id="producing-maps-in-r-courtesy-of-jake">Producing maps in <code>R</code> (courtesy of Jake)</h2>
<p>If you want to learn more about how to produce maps of states and counties in <code>R</code>, this section is for you! This is not a requirement to complete the assignment, however, so you may jump to section 3.4 and begin the assignment if you wish.</p>
<p>As with most tasks performed in R, there are many ways to produce maps. The <code>maps</code> package is useful for quickly producing basic maps of different countries, US states, or US states with counties. Try loading the <code>maps</code> and <code>mapdata</code> packages and typing the following commands into R:<br>
<code>&gt; map("usa") # Map the continental US</code><br>
<code>&gt; map("state") # Map the continental US with state boundaries</code><br>
<code>&gt; map("county") # Map the continental US with county boundaries</code><br>
<code>&gt; map(regions = "thailand") # Map of Thailand</code><br>
The <code>maps</code> package also provides other functions to add layers on top of a “base” map<br>
<code>&gt; map("county", regions = "Wisconsin") # A map of Wisconsin with county boundaries</code><br>
<code>&gt; map.text("county", regions = "Wisconsin") # Add county names to the map</code><br>
To have more control over the maps produced and to make fancier maps, you will need to branch out into other packages. The following examples make use of the package <code>ggplot2</code>. The <code>map_data()</code> function from <code>ggplot2</code> provides us with a way to access the data used in the <code>maps</code> package and provide more customization.<br>
<code>&gt; wi &lt;- map_data(map = "county", region = "Wisconsin") # Create a dataframe of our WI polygons</code><br>
<code>&gt; head(wi)</code><br>
Each row of the data in this dataframe corresponds to a “corner” or vertex of the county polygons you mapped previously. The polygons are organized into groups, which tells ggplot which corners should be connected by lines. We can plot this dataframe with the code below. The first function (<code>ggplot()</code>) tells ggplot what data to use and what variables are mapped to the <em>x</em> and <em>y</em> axes. The second function is connected to the first with a <code>+</code>, which is unique to ggplot code. You can link many ggplot functions together with + symbols to create graphs. The second function <code>geom_polygon()</code> tells ggplot that the data it is plotting should be represented as polygons with no fill color and black lines.<br>
<code>&gt; ggplot(data = wi, aes(x = long, y = lat)) +</code><br>
<code>geom_polygon(fill = NA, color = "black")</code><br>
Oops! We forgot to tell the ggplot function which points need to be connected by lines and which don’t. Let’s include the group variable this time. We’ll also add a few more lines to make the map look better.<br>
<code>&gt; ggplot(data = wi, aes(x = long, y = lat, group = group)) +</code><br>
<code>geom_polygon(fill = NA, color = "black") +</code><br>
<code>coord_fixed(1.3) + # Adjusts the aspect ratio</code><br>
<code>theme_void() # Adds a theme to make the graphic clearer</code><br>
If you are unfamiliar with the <code>ggplot2</code> package, you can find more information by googling <code>ggplot</code>.<br>
If you want to just plot the counties that exist in the dataset we’ll be working with today, you’ll need to take a few extra steps. First, we need to filter our map data so it only contains information for the counties we want to plot<br>
<code>&gt; mydata$county &lt;- tolower(mydata$county) # convert counties to lower case to match our wi data</code><br>
<code>&gt; wi_counties_subset &lt;- wi[wi$subregion %in% mydata$county, ] # This returns only the rows from the wi map data frame that have a county name that is also in the mydata data frame</code><br>
Now we can plot a map that includes just the subset of counties we’re working with.<br>
<code>&gt; ggplot(data = wi_counties_subset, aes(x = long, y = lat, group = group)) +</code><br>
<code>geom_polygon(fill = NA, color = "black") +</code><br>
<code>coord_fixed(1.3) +</code><br>
<code>theme_void()</code></p>
</section>
<section id="assignment" class="level2">
<h2 class="anchored" data-anchor-id="assignment">Assignment</h2>
<p>Read in the data. When you plot the data in a scatterplot matrix, you may see that one point suggests an unusually high number of tornadoes. Remove the row with Dodge County from the dataset. I would <strong>not</strong> ordinarily suggest this step <em>a priori</em>, but I want you to focus on fitting spatial models and not testing for outliers today. Unfortunately, given the short duration of this course, we have not been able to devote very much time to statistical tests for outliers.</p>
<ol type="1">
<li><p>The first thing you have to do in spatial data analysis with areal models is to identify the coordinates of your spatial units (i.e., what is your <span class="math inline">\(x\)</span> column, and what is your <span class="math inline">\(y\)</span> column?). For our dataset, we will use the <em>centroids</em> of each county. You could specify the coordinates from the dataframe in each command that you use, or you can simply stick them together into an object as I suggest:<br>
<code>&gt; mycoords &lt;- cbind(data$UTMEast, data$UTMNorth)</code><br>
Note that I’ve used the included UTM coordinates instead of latitude and longitude. There are arguments you can use to specify the latter, but I strongly prefer working with continuous <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> data. That makes it easier to specify neighborhood structures by distance (e.g., everyone within 50 km, rather than 0.5 <span class="math inline">\(\deg\)</span> longitude or latitude!).<br>
After specifying your spatial coordinates, you need to construct a neighborhood structure. There are many different methods for this. I’ve listed three of the most popular here, with example syntax. (<em>Don’t</em> run any code here; keep reading until instructed).</p>
<ol type="1">
<li><p>Distance-based; i.e., <span class="math inline">\(d\)</span> nearest neighbors. Syntax:<br>
<code>&gt; myneighbors &lt;- dnearneigh(mycoords, d1, d2)</code><br>
For example, for all neighbors between 0 and 75 km away, you would specify <code>d1=0, d2=75</code>.</p></li>
<li><p>Number-based; i.e., <span class="math inline">\(k\)</span> nearest neighbors. Syntax:<br>
<code>&gt; myneighbors &lt;- knn2nb(knearneigh(mycoords, k=1, longlat=NULL))</code><br>
For example, to specify the closest 2 neighbors, specify <code>k=2</code>.</p></li>
<li><p>Generate neighborhood definitions from a regular grid or lattice (not the case with today’s data). Syntax:<br>
<code>&gt; myneighbors &lt;- cell2nb(nrow, ncol, type="rook", torus=F)</code> (And, you now know what the torus argument does!)</p></li>
</ol>
<p>There are other methods and neighborhood structures, such as reading a shapefile and defining neighbors as those that share common borders, but I do not include that syntax here.</p>
<p>So, there you have a few different techniques. We’ll focus on distance- (<span class="math inline">\(d\)</span>) and number- (<span class="math inline">\(k\)</span>) based methods for this county-level data.<br>
Please construct two different neighborhood structures for the tornado data:</p>
<ol type="1">
<li><p>All neighbors within 50 km</p></li>
<li><p>Three nearest neighbors</p></li>
</ol>
<p>For the <code>summary()</code> and <code>plot()</code> functions, you do have to specify the coordinates:<br>
<code>&gt; summary(myneighbors, mycoords)</code><br>
<code>&gt; plot(myneighbors, mycoords)</code><br>
Examine both neighborhood structures visually. Comment on their differences. Which one do you think makes the most sense for a tornado analysis?</p></li>
<li><p>Now that you have a neighborhood structure (or two of them, rather), construct weighting schemes for each. The most basic is the binary coding scheme, in which cells are either defined as being neighbors (i.e., 1) or not (i.e., 0).<br>
<code>myweights &lt;- nb2listw(myneighbors, style="B")</code><br>
You can get more specialized with inverse distance weights, etc. This code is FYI only:<br>
<code>&gt; dn &lt;- dnearneigh(mycoords, 0, 100)</code><br>
<code>&gt; plot(dn, mycoords)</code><br>
<code>&gt; dlist &lt;- nbdists(dn, mycoords)</code><br>
<code>&gt; dlist &lt;- lapply(dlist, function(x) 1/x)</code><br>
<code>&gt; myweights &lt;- nb2listw(dn, style=‘‘B’’, glist=dlist)</code><br>
The above code will create neighbors of any counties that are within 100 km of each other, and define a weight that is the reciprocal of the distance between counties, scaled by the minimum distance. (But <strong>note a limitation</strong> in this approach: the distances are measured by traversing the “links” between the centroids of each county, rather than traveling in a straight line. Programming the latter is a little more complicated<span class="math inline">\(\ldots\)</span>).<br>
<strong>Note</strong> that the neighbor list and the weighting scheme are technically two different things! <em>However,</em> in R, when you create the weighting scheme, R remembers and incorporates the neighborhood structure. So, when we specify models, all we have to do is provide the weights!<br>
Let’s fit a model with a SAR error structure to account for spatial dependence. Here’s the syntax to fit a SAR model:<br>
<code>fm1 &lt;- errorsarlm(response</code><span class="math inline">\(\sim\)</span><code>covariate(s), data=data, listw=myweights)</code><br>
Fit four separate models, examining the effect of each of four covariates on the number of tornadoes. Focus on <code>Nlat</code>, <code>Wlong</code>, <code>log(pop90)</code>, and <code>sqrt(area)</code> for covariates. You will notice that I have transformed two of the covariates. To date, we have focused on transforming only the response variable when necessary to fulfill model assumptions for linear models. I found when doing this assignment that the big city of Madison in Dane County created some large skew in the population variable that sometimes made it difficult to solve parameter estimates for associated model coefficients. Hence, I encourage you to also use this simple fix, even if <code>R</code> does not encourage you to rescale the explanatory variable). For each of the four models, use the distance-based structure with a binary weighting scheme that you have already defined.<br>
Take a look at your four models, each one containing one covariate. If you were using forward selection to construct a model explaining the number of tornadoes at a county level in Wisconsin, are there any variable(s) you would summarily exclude? Why?<br>
(<strong>Note:</strong> You may see things in the output that we have not covered in class, like <span class="math inline">\(\lambda\)</span> estimates. Don’t worry about those, as they relate to parameterizing the SAR error terms.)<br>
</p></li>
<li><p>Build and report a good model out of the remaining variables. Retain the same distance-based neighborhood structure throughout to keep things simple. As you might expect, judge your model(s) by the AIC values and statistical signficance of the remaining variables.<br>
Remember to examine the residuals of your final model:</p>
<ol type="1">
<li><p>We assume that the model has satisfactorily accounted for spatial dependence. We can utilize Moran’s test on the residuals to check the independence assumption (Assumption 2). We have a neighborhood structure and weights predefined, so we type:<br>
<code>&gt; mycheck &lt;- moran.test(fm1$resid, myweights, alternative="two.sided")</code><br>
<code>&gt; mycheck</code><br>
If the <span class="math inline">\(p\)</span>-value is <span class="math inline">\(&gt;0.05\)</span>, Moran’s I statistic is not significantly different from zero, providing no evidence that there is spatial autocorrelation remaining in the residuals.</p></li>
<li><p>Further, we still assume that any residual error left over, even after accounting for spatial variation, is homoscedastic and normally distributed (Assumptions 3 and 4 of linear models). Hence, we examine the residual plot:<br>
<code>&gt; plot(fm1$residuals</code><span class="math inline">\(\sim\)</span><code>fm1$fitted.values)</code><br>
</p></li>
</ol></li>
<li><p>After you have found a satisfactory model, change the weighting scheme.</p>
<p>Fit the same final model using the nearest neighbor weights, rather than the distance weights. Rather than focusing on the exact numbers of the slopes of each covariate, looks at the trends and relative magnitudes. Did the sign and significance of your model coefficients change? How about the spatial dependence, distribution, and homoscedasticity in the residuals? Is this model substantially similar to the previous one?<br>
</p></li>
<li><p>Finally, fit the same final model, this time ignoring any spatial error structure using our old friend the <code>lm()</code> command. Are the results substantially similar? (i.e., slopes, significance, residual plots, etc.). While examining <span class="math inline">\(R^2\)</span> values are the most conventional methods of examining regular linear regressions, you <em>can</em> extract an AIC value using<br>
<code>&gt; AIC(mymodel)</code><br>
so you can compare it to the previous spatial fits using likelihood methods. Do a Moran test on the residuals of this model, using either the distance-based or nearest neighbor weights, looking for evidence of spatial dependence.<br>
Examine your results. Hmmm. Which model would you choose? Why?<br>
</p></li>
</ol>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2025, Jeremy Hemberger</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>Built with <a href="https://www.r-project.org/about.html" target="_blank"><i class="fa-brands fa-r-project" title="R Project" aria-label="r-project"></i></a> and <a href="https://quarto.org/" target="_blank">Quarto</a></p>
</div>
  </div>
</footer>




</body></html>