<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Jeremy Hemberger and Brian Aukema">
<meta name="dcterms.date" content="2025-07-25">

<title>Lab 10: Spatial point processes: Ripley’s K – Entomology 5126</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<link href="../media/web-favicon.png" rel="icon" type="image/png">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<link href="../site_libs/quarto-contrib/fontawesome6-1.2.0/all.min.css" rel="stylesheet">
<link href="../site_libs/quarto-contrib/fontawesome6-1.2.0/latex-fontsize.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../index.html" class="navbar-brand navbar-brand-logo">
    <img src="../media/5126-sticker.png" alt="" class="navbar-logo">
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../syllabus.html"> 
<span class="menu-text">Syllabus</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../schedule.html"> 
<span class="menu-text">Schedule</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../content/index.qmd"> 
<span class="menu-text">Content</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../lab/index.html"> 
<span class="menu-text">Labs</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../resources.html"> 
<span class="menu-text">Resources</span></a>
  </li>  
</ul>
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../media/ent5126-syllabus_sp2026.pdf" target="_blank"> <i class="bi bi-file-pdf" role="img">
</i> 
<span class="menu-text">Course Syllabus</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/jhemberger/entomology-5126" target="_blank"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="mailto:jhemberg@umn.edu"> <i class="bi bi-envelope" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-full page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction">Introduction</a></li>
  <li><a href="#todays-data" id="toc-todays-data" class="nav-link" data-scroll-target="#todays-data">Today’s data</a></li>
  <li><a href="#todays-assignment" id="toc-todays-assignment" class="nav-link" data-scroll-target="#todays-assignment">Today’s Assignment</a>
  <ul class="collapse">
  <li><a href="#ripleys-k" id="toc-ripleys-k" class="nav-link" data-scroll-target="#ripleys-k">Ripley’s K</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content column-page-left" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Lab 10: Spatial point processes: Ripley’s K</h1>
<p class="subtitle lead">Entomology 5126 - Spring 2026</p>
</div>



<div class="quarto-title-meta column-page-left">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Jeremy Hemberger and Brian Aukema </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">July 25, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<hr>
<section id="introduction" class="level1">
<h1>Introduction</h1>
<p>Today we will work with Ripley’s K functions, which can tell us whether a spatial point process is random, regular, or clumped. As we discussed in class, the intensity, <span class="math inline">\(\lambda\)</span>, of events over a surface is typically considered to be Poisson distributed. A Poisson point process assumes three things:</p>
<ol type="1">
<li><p>Events occur singly</p></li>
<li><p>Expected number of events is the same in all possible subregions of the same size</p></li>
<li><p>The occurrence of an event in one subregion is independent of the occurrence of an event in another non-overlapping subregion</p></li>
</ol>
<p>Ripley’s K functions can be <em>univariate</em>, where you are only examining one point pattern (e.g., spatial patterns of dandilions in a field), or <em>bivariate</em>, where you examine how two point patterns interact (e.g., do dandilions have no spatial relationship with bunny rabbits in a field, or are they clustered together (aggregation), or are dandilions found wherever rabbits are not (inhibition?)). Bivariate K functions are sometimes known as <em>K-cross</em> functions because you are examining how two point patterns interact.</p>
</section>
<section id="todays-data" class="level1">
<h1>Today’s data</h1>
<p>Today’s data, in <code>Lab10data.xls</code>, are from Dr.&nbsp;W.A. Aherne in the Department of Pathology, University of Newcastle-upon-tyne, UK. This is a spatial point process dataset, where the events are the positions of the centres of nuclei of certain cells in a histological section of tissue from a laboratory-induced metastasising lymphoma in the kidney of a hamster.<br>
A point process typically only contains information on the <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> locations. These data comprise a super-special type of point process, a <em>marked</em> spatial point process. <em>Marks</em> are data that characterize events in the spatial point process beyond their <span class="math inline">\(x,y\)</span> locations. For example, a data set of trees may not only have two columns for <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> positions, but also a column for diameters. In this data set, the cells are marked: they are classified into two types: “pyknotic” (i.e., dying) and “dividing” (i.e., living). The background white space is occupied by unrecorded, interphase cells that are not recorded and considered to be of no consequence to the present analysis.<br>
The sampling window is a square, 250 <span class="math inline">\(\mu\)</span>m <span class="math inline">\(\times\)</span> 250 <span class="math inline">\(\mu\)</span>m. In this data set, it has been rescaled to the unit square (i.e., between 0 and 1). There are three columns:</p>
<div class="center">
<p>Variable Description</p>
<hr>
<p>x <span class="math inline">\(x\)</span> position y <span class="math inline">\(y\)</span> position type marks; two levels: pyknotic or dividing</p>
</div>
</section>
<section id="todays-assignment" class="level1">
<h1>Today’s Assignment</h1>
<section id="ripleys-k" class="level2">
<h2 class="anchored" data-anchor-id="ripleys-k">Ripley’s K</h2>
<p>Load the <code>spatstat</code> package today. This package was originally written by Adrian Baddeley (Curtin University), Ege Rubak (Aalborg University), and Rolf Turner (now retired, formerly of University of New Brunswick). This package is the premier package for working with spatial point process data. The two senior authors Baddeley and Turner instituted a bold change from historic classroom terminology that I like very much. For distance metrics in the K function, they use <span class="math inline">\(r\)</span> for radius, which is still a type of distance, rather than <span class="math inline">\(t\)</span>.</p>
<ol type="1">
<li><p>After loading the <code>spatstat</code> package, load the data. As usual, do a <code>summary()</code> to ensure the data were loaded properly. In today’s data set, the marks are a factor with two levels, so be sure to convert the <em>type</em> column to a factor as necessary. Again, as good practice, use the <code>summary()</code> command on your data set to check that your variable types are properly defined both before and after an operation.</p></li>
<li><p>Now, use subsetting or row selection techniques to create two more dataframes containing <em>only</em> the dividing cells, and <em>only</em> the pyknotic cells. You should now have <strong>three</strong> data sets.<br>
</p></li>
<li><p>To this point in the course, when we have read in data, the resulting object has been a <em>dataframe</em> that we can then examine with a <code>summary()</code>, explore with a scatterplot matrix, etc. Today, we are going to work with a slightly different object, a <em>planar point process</em>, abbreviated <code>ppp</code>.<br>
Convert each dataframe to a planar point process. Here’s the relevant syntax, with explanation following:<br>
<code>&gt; my.ppp.marked &lt;- ppp(x=mydata$x, y=mydata$y, window=square(1), marks=mydata$type)</code><br>
The first two arguments in the <code>ppp()</code> command specify where to find the spatial locations. The <code>window</code> specifies what the sample area looks like. I have used the simplest specification, a square with sides of length=1. The <code>window</code> argument is actually very flexible; you can provide coordinates from shapefiles, polygons with holes, rectangles, and more. (See a full description in the help file using <code>?window</code> if you would like to investigate further with your own data).<br>
The final argument, <code>marks</code>, specifies where to find the marks in your dataframe (here, in the <code>type</code> column). <em>Note</em>: If you are working with a <em>univariate</em> dataset that only contains one type of mark (e.g., only dividing cells or only maple trees, so you only have two columns with <em>x</em>’s and <em>y</em>’s to denote the events locations), then you do <em>not</em> need to include the <code>marks</code> argument.<br>
You should now have three <code>ppp</code> objects, one for the full dataset with marks, and one for each of your univariate subsets for dividing and pyknotic cells (without marks). Be sure to name them something meaningful.<br>
</p></li>
<li><p>Next, do a <code>summary()</code> on the resulting object from the <code>ppp()</code> from the full dataset with marks. You should see a helpful table of the total number of cells that are dividing vs.&nbsp;dying, their relative proportions, and the expected intensity, <span class="math inline">\(\lambda\)</span>, per unit area.</p>
<p>First assignment question: given that the unit square in our data set is actually 250 <span class="math inline">\(\mu\)</span>m long, what is the intensity of <em>dividing</em> cells on a per mm<span class="math inline">\(^2\)</span> basis?</p></li>
<li><p>Let’s work now with the dying, pyknotic cells. As you saw in the previous question, a <code>summary()</code> of the point process returns the intensity and details of the window in a point process without marks. Plot the point process for the pyknotic cells (I think you can guess the syntax). The pyknotic cells will show up as circles, since there is only one type of mark.</p>
<p>From a strictly visual examination, do you think the dying cells appear to be clustered, random, or regularly spaced?</p></li>
<li><p>The human eye is actually trained to look for patterns. As such, <strong>we are by nature terrible at visually examining and diagnosing complete spatial randomness</strong>. Hence, Ripley’s K is a useful quantitative technique. Continue working with the point process restricted to these <strong>pyknotic</strong> cells.</p>
<p>The syntax for Ripley’s K is fairly simple. We use the estimation function, <code>Kest()</code>:<br>
<code>&gt; myRipleysK.pyknotic &lt;- Kest(my.ppp.pyknotic, correction="best")</code><br>
The first argument specifies the univariate planar point process (i.e., no marks - you are only looking at one type of cell). The second argument to the function specifies the border correction.<br>
The <code>Kest()</code> command has many different border correction options that have different statistical properties (e.g., efficiency/speed of calculation, robustness to smaller data sets, shapes of windows, etc.). One of the most useful for square or rectangular geometries is Ripley’s <em>isotropic</em> correction. The technique I simply recommend is to specify the option <code>correction="best"</code>. Believe it or not, the creators of the package have developed a number of rules to calculate the best method based on your data set!<br>
Now, <code>plot()</code> the resulting K function. You should see a <strong>theoretical <span class="math inline">\(K\)</span></strong> line (might be blue), with a squiggly <strong>empirical <span class="math inline">\(\hat{K}\)</span></strong> line. What border correction did the program choose for you?</p></li>
<li><p>If you were to try different border corrections, you would likely find that they all look somewhat similar. Just for fun, calculate Ripleys’ K without the <code>correction</code> argument and then plot the result. The resulting graph will plot the various empirical <span class="math inline">\(\hat{K}\)</span> lines denoting differing types of border corrections.<br>
Any one of these empirical <span class="math inline">\(\hat{K}\)</span> line(s), while helpful, are not terribly informative, since they do not tell us how far above or below the theoretical line one needs to be to be considered “significant.”<br>
Instruct your computer to construct a simulation envelope. With the simulation envelope, the computer randomizes the point pattern 1,000 times, calculates the empirical K function, and then takes off a specified percentile of top and bottom runs to construct a simulation or confidence envelope. Be patient; it may take a few minutes depending on the speed of your machine!<br>
<code>&gt; my.env.pyknotic &lt;- envelope(my.ppp.pyknotic, Kest, nsim=999, nrank=25)</code><br>
Plot the envelope using <code>plot(my.env.pyknotic)</code>. You should see a nice shaded region with somewhat-symmetric upper and lower confidence lines now.</p>
<ol type="1">
<li><p>What size of confidence interval is constructed by doing 999 simulations (in addition to the 1 real data set) and taking away the maximum and minimum 25 runs?</p></li>
<li><p>How would you change the arguments if you wanted a 99% confidence interval?</p></li>
</ol></li>
<li><p>It can be difficult to see where the empirical line crosses a theoretical boundary line on a quadratic scale, so plot one of these transformations instead:<br>
<code>&gt; plot(myenv, sqrt(./pi)</code><span class="math inline">\(\sim\)</span><code>r)</code><br>
<code>&gt; plot(myenv, (sqrt(./pi)-r)</code><span class="math inline">\(\sim\)</span><code>r)</code><br>
What is the name of the function that you have just plotted?</p></li>
<li><p>Looking at your Ripley’s K function with confidence intervals, do you see evidence of clustering or regular spacing in the pyknotic cells? Does this agree with your initial guess at what the pattern would look like from visual inspection?<br>
</p></li>
<li><p>Let’s do some work with Ripley’s <em>bivariate</em> K, sometimes known as K-cross functions. First, let’s check the summary of the entire marked point process (i.e., whole data set). You may need to go back to question 1 to remember where you left it.</p>
<p><code>&gt; summary(my.ppp.marked)</code><br>
And graph the process:<br>
<code>&gt; plot(my.ppp.marked, cols=c("black", "red"))</code><br>
You can see I’ve added some colour to the graph for visual distinction. From visual inspection, do you think that the dividing cells are found next to or far away from the dying, pyknotic cells? Or is there no relation (i.e., complete spatial randomness)?</p></li>
<li><p>Construct and plot Ripley’s bivariate K function for the interaction between the dividing and pyknotic cells (i.e., using the marked point process). The syntax is identical to what you have worked with in previous questions, except that you now must (1) use <code>Kcross()</code> instead of <code>Kest()</code> to estimate the K-function (again, use the <code>correction="best"</code> argument within <code>Kcross()</code>) and (2) specify the marked point process where you previously specified the univariate planar point process for pyknotic cells. Simulation envelopes are constructed as before, with a reminder that construction may take a few minutes because the computer is now randomizing <em>two</em> point processes multiple times.</p>
<p>Do dying cells tend to be clustered, far away from, or completely independent (i.e., random) from dividing cells? If you see a significant pattern, at what spatial scale(s) does it occur? (Remember that these data have been rescaled).</p></li>
</ol>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2025, Jeremy Hemberger</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
<p>Built with <a href="https://www.r-project.org/about.html" target="_blank"><i class="fa-brands fa-r-project" title="R Project" aria-label="r-project"></i></a> and <a href="https://quarto.org/" target="_blank">Quarto</a></p>
</div>
  </div>
</footer>




</body></html>